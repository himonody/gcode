# Kafka 消息去重方案对比

## 两种方案总览

| 特性 | Redis String (SET NX) | Redis 布隆过滤器 |
|------|----------------------|------------------|
| **准确率** | 100% | 99%~99.99% (可配置) |
| **内存占用** | 高 (每条约100字节) | 极低 (1000万条仅12MB) |
| **查询速度** | 极快 (单次操作) | 快 (k次操作,k为哈希函数数) |
| **可删除** | ✅ 支持 | ❌ 不支持 |
| **适用规模** | 百万~千万级/天 | 千万~亿级/天 |
| **实现复杂度** | 简单 | 中等 |

---

## 方案一：Redis String + SET NX

### 原理

```bash
# 使用 Redis SET 命令的 NX 选项实现原子性的"检查并设置"
SET idempotent:order-123 "2024-01-22T10:00:00Z" NX EX 86400

# 返回 OK: 键不存在，设置成功，首次处理
# 返回 nil: 键已存在，已处理过，跳过
```

### 内存计算

```
单条消息内存占用 = 键长度 + 值长度 + Redis开销
                = 30 (idempotent:order-123)
                + 20 (时间戳)
                + 50 (Redis内部结构)
                = 100 bytes

1000万条消息 = 10,000,000 × 100 bytes = 1GB
1亿条消息   = 100,000,000 × 100 bytes = 10GB
```

### 优点

✅ **准确率 100%**: 无误判，业务逻辑简单
✅ **操作简单**: 单条命令完成检查和设置
✅ **可删除**: 支持手动删除键
✅ **自动过期**: TTL 自动清理旧数据
✅ **易于调试**: 可直接查看 Redis 中的键值

### 缺点

❌ **内存占用高**: 大规模场景下内存成本较高
❌ **无法压缩**: 每条消息都占用固定空间

### 使用示例

```go
// 创建 Redis 存储
redisStore, err := idempotency.NewRedisStore(
    "localhost:6379",  // Redis 地址
    "",                // 密码
    0,                 // DB
    24*time.Hour,      // 过期时间
    true,              // 启用降级
)

// 检查幂等性
isFirst, err := redisStore.CheckAndSet(ctx, "order-123")
if isFirst {
    // 首次处理
    processBusiness()
}
```

### 适用场景

- ✅ 消息量：**百万~千万级/天**
- ✅ 对准确性要求极高
- ✅ 内存成本可接受
- ✅ 需要手动删除或查询去重记录

---

## 方案二：Redis 布隆过滤器

### 原理

```
布隆过滤器 = 位数组 + 多个哈希函数

添加元素：
  key -> hash1(key) -> 设置 bit[位置1] = 1
      -> hash2(key) -> 设置 bit[位置2] = 1
      -> hash3(key) -> 设置 bit[位置3] = 1

检查元素：
  key -> hash1(key) -> 检查 bit[位置1] == 1?
      -> hash2(key) -> 检查 bit[位置2] == 1?
      -> hash3(key) -> 检查 bit[位置3] == 1?

  所有位都为1 -> 元素可能存在（可能误判）
  任一位为0  -> 元素肯定不存在
```

### 内存计算

使用公式自动计算最优参数：

```
位数组大小 m = -n × ln(p) / (ln(2))²
哈希函数数 k = (m/n) × ln(2)

其中：
  n = 预期元素数量
  p = 目标误判率
  m = 位数组大小（bit）
  k = 哈希函数个数
```

**实际占用：**

| 预期消息量 | 误判率 | 位数组大小 | 内存占用 | 哈希函数数 |
|-----------|--------|-----------|---------|-----------|
| 100万 | 1% | 9.6Mb | 1.2MB | 7 |
| 1000万 | 1% | 96Mb | 12MB | 7 |
| 1亿 | 1% | 959Mb | 120MB | 7 |
| 1000万 | 0.1% | 144Mb | 18MB | 10 |

### 优点

✅ **内存极低**: 1000万消息仅需 12MB（误判率1%）
✅ **查询快速**: O(k) 时间复杂度
✅ **可配置**: 可根据业务需求调整误判率
✅ **按天轮转**: 自动切换布隆过滤器，清理过期数据
✅ **适合超大规模**: 支持亿级消息

### 缺点

❌ **存在误判**: 可能将未处理的消息误判为已处理
❌ **无法删除**: 布隆过滤器不支持删除操作
❌ **需要预估**: 需提前确定预期消息数量
❌ **调试困难**: 无法查看具体哪些元素在过滤器中

### 误判率说明

**误判率 = 将"不存在"误判为"存在"的概率**

```
误判率 1%:
  - 100个首次处理的消息，1个可能被误判为已处理
  - 适合大部分业务场景

误判率 0.1%:
  - 1000个首次处理的消息，1个可能被误判为已处理
  - 适合对准确性要求更高的场景
  - 内存占用增加约 50%
```

### 使用示例

```go
// 创建布隆过滤器存储
bloomStore, err := idempotency.NewBloomStore(idempotency.BloomStoreConfig{
    Addr:            "localhost:6379",
    Password:        "",
    DB:              0,
    KeyPrefix:       "bloom:",
    ExpectedItems:   10000000,      // 预期 1000万消息/天
    FalsePositive:   0.01,          // 1% 误判率
    TTL:             24 * time.Hour,
    EnableDegrade:   true,
})

// 检查幂等性（与 Redis String 接口一致）
isFirst, err := bloomStore.CheckAndSet(ctx, "order-123")
if isFirst {
    // 首次处理（可能有 1% 的误判）
    processBusiness()
}
```

### 适用场景

- ✅ 消息量：**千万~亿级/天**
- ✅ 对内存成本敏感
- ✅ 可容忍极低的误判率（< 1%）
- ✅ 无需删除或查询去重记录

---

## 性能对比

### QPS 测试 (单机 Redis)

| 方案 | 单次查询 | 批量查询(100条) | 延迟(P99) |
|------|---------|----------------|----------|
| Redis String | 10w+ QPS | 8w+ QPS | < 1ms |
| 布隆过滤器(k=7) | 5w+ QPS | 4w+ QPS | < 2ms |

### 内存对比 (1000万消息，24小时)

| 方案 | 内存占用 | 成本/月 (按0.1元/GB算) |
|------|---------|-------------------|
| Redis String | 1GB | 3元 |
| 布隆过滤器(1%) | 12MB | 0.04元 |
| 布隆过滤器(0.1%) | 18MB | 0.06元 |

---

## 选择建议

### 使用 Redis String 如果：
- 消息量 < 1000万/天
- 必须保证 100% 准确
- 内存成本可接受（< 1GB）
- 需要手动删除或查询记录

### 使用布隆过滤器如果：
- 消息量 > 1000万/天
- 可接受 < 1% 的误判率
- 对内存成本敏感
- 不需要删除或查询记录

---

## 混合方案（最优实践）

对于超大规模场景，可以采用**布隆过滤器 + Redis String** 双重验证：

```go
// 1. 先用布隆过滤器快速过滤（拦截 99% 的重复）
exists, _ := bloomStore.CheckAndSet(ctx, msgID)
if !exists {
    // 布隆过滤器判断不存在，肯定是首次处理
    processBusiness()
    return
}

// 2. 布隆过滤器判断存在（可能误判），用 Redis String 二次验证
isFirst, _ := redisStore.CheckAndSet(ctx, msgID)
if isFirst {
    // Redis String 确认首次处理
    processBusiness()
}
```

**优势：**
- 内存占用低：99% 的重复消息被布隆过滤器拦截，只有 1% 进入 Redis String
- 准确率 100%：通过二次验证消除误判
- 适合超大规模 + 高准确性场景

---

## 代码切换

两种方案接口完全一致，只需修改初始化代码即可切换：

```go
// 切换到 Redis String
store, err := idempotency.NewRedisStore(...)

// 切换到布隆过滤器
store, err := idempotency.NewBloomStore(idempotency.BloomStoreConfig{...})

// 使用方式完全相同
isFirst, err := store.CheckAndSet(ctx, msgID)
```

---

## 总结

| 场景 | 推荐方案 | 理由 |
|------|---------|------|
| 中小规模 (< 1000万/天) | Redis String | 简单、准确、够用 |
| 大规模 (1000万~1亿/天) | 布隆过滤器 (1%) | 内存节省 99%，误判可接受 |
| 超大规模 (> 1亿/天) | 布隆过滤器 (0.1%) | 内存节省 98%，误判更低 |
| 超大规模 + 高准确性 | 布隆过滤器 + String | 混合方案，兼顾内存和准确性 |

**当前代码默认使用布隆过滤器，可在 main.go 中切换。**
